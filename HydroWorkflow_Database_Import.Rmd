---
title: "Medsal-HydroWorkflow"
author: ""
date: ""
output:
  html_document:
    df_print: paged
  pdf_document: default
classoption:
- twocolumn
- landscape
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
knitr::opts_chunk$set(message = FALSE)
```

```{r Install packages, eval=FALSE, include=FALSE}
#Install packages ( only needed when using the script for the first time!)
install.packages(c("readxl","PeriodicTable","knitr","ggplot2", "ggmap","plotly","factoextra","tibble","cluster","purr","tidyr", "magrittr", "scales","reshape2","directlabels", "dplyr", "hydrogeo", "ggrepel","readxl","ggplot2", "knitr","PeriodicTable","RMySQL","devtools","processx","plyr"))
```

```{r Set working directory, include=FALSE}
# By default the working directory is set below to be the folder containing the RMarkdown file
wd = getwd()
setwd(wd)
```

```{r Retrieving data from the database, message=FALSE, warning=FALSE, include=FALSE}

### Load library
library(RMySQL)
library(dplyr)
### Connect to the database
mydb <- dbConnect(
  MySQL(),
  user = 'uhydro_16_r',
  password = 'MiRcTD69aRAYn2Ji',
  dbname = 'uhydro_db16',
  host = 'sql628.your-server.de'
)

### Assign geochemical data from the Medsal database to the medsalgeochem data.frame
rs = dbSendQuery(mydb, "select * from Geochemical")
medsalgeochem = fetch(rs, n = -1)
dbClearResult(rs)

### Assign isotopic data to medsalisotopes
iso = dbSendQuery(mydb, "select * from Isotopes")
medsalisotopes = fetch(iso)

### Clean up
rm("iso", "mydb", "rs")
############################################################################

### Tidy up the geochemical database 
# Select only rows for which Na,Mg,K,Ca,Cl,HCO3 and SO$ are >0 
medsalgeochem = medsalgeochem %>% 
  filter(Na > 0, Mg > 0, K > 0, Ca > 0 , Cl > 0, HCO3 > 0, SO4 >0) 

# Remove the time indication from the date column
medsalgeochem$date = substr(medsalgeochem$date, 1,10)
# Creates new column with the year and month of each sample
medsalgeochem$code_date = substr(medsalgeochem$date, 1,7)

# Creates column where each year and month is added to the respective sample so that there are no rows with the same medsal code 
medsalgeochem$new= paste(medsalgeochem$medsal_code, medsalgeochem$code_date, sep="_")

# Rename the new column to Sample so as to use these 
medsalgeochem$Sample = medsalgeochem$new

#Select only one sample with the same sample code 
medsalgeochem = medsalgeochem %>% distinct(Sample, .keep_all = TRUE)
# date column to be recognized as date
medsalgeochem$date = as.Date(medsalgeochem$date)
# A column for the site code e.g. Rhodope - RHO 
medsalgeochem$MedsalCode = as.factor(substr(medsalgeochem$Sample, 1, 3)) 



```

```{r eval=FALSE, include=FALSE}

### Tidy up the isotopic database 

# Remove the time indication from the date column
#medsalisotopes$date = substr(medsalisotopes$date, 1,10)
# Creates new column with the year and month of each sample
medsalisotopes$code_date = substr(medsalisotopes$date, 1,7)

#Creates column where each year and month is added to the respective sample so that there are no rows with the same medsal code 
#medsalisotopes$neu= paste(medsalisotopes$medsal_code, medsalisotopes$code_date, sep="_")

library(plyr)

# Assign the new column to Sample 
#medsalisotopes$Sample = medsalisotopes$neu

# Virtual dataframe with NA for samples with no isotopic data
#combined <- rbind.fill(medsalgeochem["Sample"], medsalisotopes[c("Sample", "dO18","d2H","date")])
```
------------------------------------------------------------------------

```{r Provide the instructions for your run}

#▐▓█▀▀▀▀▀▀▀▀▀█▓▌░▄▄▄▄▄░ # PLease notice that the variables Sample,Na,Mg,K,Ca,Cl,HCO3,SO4,date must
#▐▓█░░▀░░▀▄░░█▓▌░█▄▄▄█░ # be included for the script to run!  
#▐▓█░░▄░░▄▀░░█▓▌░█▄▄▄█░
#▐▓█▄▄▄▄▄▄▄▄▄█▓▌░█████░
#░░░░▄▄███▄▄░░░░░█████░

# 1) Choose the area you want to examine by providing the Medsal Code ( e.g. RHO )

medsalgeochem = subset(medsalgeochem,MedsalCode=="RHO")  

# 2) Choose the period of interest 

#  <	less than
#  <=	less than or equal to
#  >	greater than
#  >=	greater than or equal to
#  ==	exactly equal to

medsalgeochem = subset(medsalgeochem, date >= "2020-01-01" )

#water_analysis = subset(water_analysis, date >= "2020-01-01" & date =< "2021-01-01")

# 3) Choose the variables to be considered________________________________________

medsalgeochem = medsalgeochem %>% 
  select(Sample,Na,Mg,K,Ca,Cl,HCO3,SO4,Br,NO3,utm_x,utm_y,laea_x,laea_y,projection,date)

water_analysis = medsalgeochem

#_________________________________________________________________________________


# 4) Clustering

#Choose the similarity measure to be used ( "manhattan", "euclidean", "maximum", "canberra", "binary", "minkowski")

sim_meas = "manhattan" 

# Choose the agglomeration method ("complete", "average", "single", "ward.D")
agg_method =  "ward.D" 
# Choose the number of clusters for the dendrogram 
numberofclusters = 5

#__________________________________________________________________________________
#                                        Knit!                                    
#__________________________________________________________________________________


```

------------------------------------------------------------------------

# 1.Data quality assessment

## 1.1. Data overview

```{r View your original data, echo=FALSE, message=FALSE, warning=FALSE}
library(knitr)
kable(water_analysis, align = 'c', caption = 'The studied water analyses ($mg/L$)')
```

## 1.2. Charge balance error

An assessment of the hydrogeochemical data at hand is crucial for the quality of the following modeling procedure and therefore constitutes the first processing stage. A routine validation is checking the **electroneutrality** of the water. Aqueous solutions must be electrically neutral hence the total sum of all the positive charges (cations) must equal the total sum of all negative charges (anions):

$$ \sum eq_{c a t i o n s}=\sum eq_{a n i o n s}$$

$$
\sum m_c * z_c =\ \sum m_a*|z_a|
$$

Where $eq_{ions}$ is in $meq/L$, therefore the original data was transformed from accordingly from $mg/L$ to $meq/L$.

```{r Transform your data from mg/l to meq/l, message=FALSE, warning=FALSE, include=FALSE}
library("PeriodicTable")

#Basic ions
Na_meq = c(water_analysis$Na / mass('Na') * 1)
K_meq = c(water_analysis$K / mass('K') * 1)
Mg_meq = c(water_analysis$Mg / mass('Mg') * 2)
Ca_meq = c(water_analysis$Ca / mass('Ca') * 2)
Cl_meq = c(water_analysis$Cl / mass('Cl') * 1)
SO4_meq = c(water_analysis$SO4 / (mass("S") + 4 * mass("O")) * 2)
HCO3_meq = c(water_analysis$HCO3 / (mass("H") + mass("C") + 3 * mass("O")) *1)

# Further ions 

if("NO3" %in% colnames(water_analysis)) {
  NO3_meq = c(water_analysis$NO3 / (mass("N") + 3 * mass("O")) * 1)
}


if("Br" %in% colnames(water_analysis)) {
  Br_meq = c(water_analysis$Br / (mass("Br")) * 1)
}

if("CO3" %in% colnames(water_analysis)) {
  CO3_meq = c(water_analysis$CO3 / (mass("C") + 3 * mass("O")) * 2)
}

```

The use of the **Charge Balance Error (CBE)** quantifies the balance of the analysis. Positive CBE values indicate more anions than cations and vice versa. $$CBE = \frac{\sum anions -\sum cations}{\sum anions+\sum cations} * 100$$

Charge Balance Error was calculated for every sample as presented in Table 2.

```{r Charge Balance Error calculation, echo=FALSE, message=FALSE, warning=FALSE}
  
cations = Na_meq + K_meq + Mg_meq + Ca_meq
anions = Cl_meq + SO4_meq + HCO3_meq

if(exists("NO3_meq")){
  anions = anions + NO3_meq
}

if(exists("Br_meq")){
  anions = anions + Br_meq
}

if(exists("CO3_meq")){
  anions = anions + CO3_meq
}

# Calculate the charge balance error
C_B_E = (cations - anions) / (cations + anions) * 100

# Add a column with the CBE to the dataset
analysis_CBE <- water_analysis
analysis_CBE$CBE = C_B_E

# Please make sure that the sample name is the first column
library(knitr)
kable(analysis_CBE[, c(1, ncol(analysis_CBE))], align = 'c',  caption = 'Water samples and their respective CBE(%)')
```

Systematic errors in the sampling procedure and the overall number of suitable or not samples, can be evaluated by looking at the distribution of the CBE error:

```{r Distribution of the CBE error, echo=FALSE, fig.height=2, fig.width=8, message=FALSE, warning=FALSE}

library(ggplot2)

plot1_density = ggplot(analysis_CBE, aes(CBE)) +
  geom_density(color = "darkblue", fill = "lightblue") +
  geom_vline(
    aes(xintercept = 5),
    size = 1,
    color = "red",
linetype = "dashed"
) +
  geom_vline(
aes(xintercept = -5),
 size = 1,
 color = "red",
linetype = "dashed"
) +
  theme_light() +
  xlab("CBE %") +
  ylab("Density")

plot1_density 
```

Samples with CBE higher than ±5% are presented in Table 3

```{r View samples in which |CBE| exceeds 5%, echo=FALSE}
Large_imbalance=analysis_CBE[abs(analysis_CBE$CBE) > 5,]

library(knitr)
kable(Large_imbalance,align = 'c',  caption = 'Samples that exceed the 5% CBE')
```

Samples with a charge imbalance up to ±5%, as indicated by the CBE, are accepted otherwise the sample is dismissed from the dataset and any further analysis.

```{r Exclude samples with high charge imbalance, include=FALSE}
water_analysis = analysis_CBE[abs(analysis_CBE$CBE) < 5,]
```

```{r Recalculate meq/L for the new dataset, message=FALSE, warning=FALSE, include=FALSE}
library("PeriodicTable")

#Basic ions
Na_meq = c(water_analysis$Na / mass('Na') * 1)
K_meq = c(water_analysis$K / mass('K') * 1)
Mg_meq = c(water_analysis$Mg / mass('Mg') * 2)
Ca_meq = c(water_analysis$Ca / mass('Ca') * 2)
Cl_meq = c(water_analysis$Cl / mass('Cl') * 1)
SO4_meq = c(water_analysis$SO4 / (mass("S") + 4 * mass("O")) * 2)
HCO3_meq = c(water_analysis$HCO3 / (mass("H") + mass("C") + 3 * mass("O")) *1)

# Further ions 

if("NO3" %in% colnames(water_analysis)) {
  NO3_meq = c(water_analysis$NO3 / (mass("N") + 3 * mass("O")) * 1)
}


if("Br" %in% colnames(water_analysis)) {
  Br_meq = c(water_analysis$Br / (mass("Br")) * 1)
}

if("CO3" %in% colnames(water_analysis)) {
  CO3_meq = c(water_analysis$CO3 / (mass("C") + 3 * mass("O")) * 2)
}

```

The amount of TDS ( Total dissolved ions) in the water samples was computed and added to the dataset.

```{r Theoretical computation of TDS, include=FALSE}

water_analysis <- transform(water_analysis, TDS = (Na + K + Mg + Ca + Cl + HCO3+ SO4))

if("NO3" %in% colnames(water_analysis)) {
  water_analysis$TDS = water_analysis$TDS + water_analysis$NO3
}


if("Br" %in% colnames(water_analysis)) {
  water_analysis$TDS = water_analysis$TDS + water_analysis$Br
}

if("CO3" %in% colnames(water_analysis)) {
   water_analysis$TDS = water_analysis$TDS + water_analysis$CO3
}
```

```{r First Housekeeping, include=FALSE}

# Housekeeping! 
rm(list=c("anions","cations","analysis_CBE","C_B_E","analysis_CBE","Large_imbalance","plot1_density"))
```

------------------------------------------------------------------------

# 2. Cluster analysis

## 2.1. Data preparation

Log-transforming highly skewed variables and standardization to 0 mean and 1 sd ( z-scoring).

```{r Create data subset to perform cluster analysis, message=FALSE, warning=FALSE, include=FALSE}
library(dplyr)
library(magrittr)
library(knitr)
library(tidyr)
library(purrr)

# Create a subset of the water_analysis dataframe to calculate the clusters from
water_analysis_clust = water_analysis %>% 
  select(Sample,Cl,HCO3,SO4,Ca,Mg,Na,K)

if("NO3" %in% colnames(water_analysis)) {
  water_analysis_clust$NO3 = water_analysis$NO3
}


if("Br" %in% colnames(water_analysis)) {
  water_analysis_clust$Br = water_analysis$Br
}


if("CO3" %in% colnames(water_analysis)) {
  water_analysis_clust$CO3 = water_analysis$CO3
}

```

The skewness of the samples was examined by plotting the distribution of the ions:

```{r Examine the skewness, echo=FALSE, fig.height=4, fig.width=8}
library(dplyr)
library(ggplot2)
library(tibble)

### Look at the distribution of the ions
water_analysis_clust %>% 
  keep(is.numeric) %>% 
  gather() %>%
  ggplot(aes(value)) +                     
    facet_wrap(~ key, scales = "free") +   
    geom_density(color="darkblue", fill="lightblue") + theme_light()+ xlab("")
```

Departure from a more "Normal" distribution was mitigated by applying a $log_{10}$ transformation to all ions as shown in the plot below. The relative differences and ratios are not altered whilst the range of numeric values decreases.

```{r log10 transform, echo=FALSE, fig.height=4, fig.width=8}

library(dplyr)
library(ggplot2)
library(tibble)

# We assign the samples' names column to the data frame's row names so as to maintain them in the following scaling
water_analysis_clust = water_analysis_clust%>% 
  remove_rownames %>% 
  column_to_rownames(var="Sample")

water_analysis_clust <- log10(water_analysis_clust)


water_analysis_clust %>% 
  keep(is.numeric) %>% 
  gather() %>%
  ggplot(aes(value)) +                     
    facet_wrap(~ key, scales = "free") +   
    geom_density(color="darkblue", fill="lightblue") + theme_light()+ xlab("")

```

To ensure a common scale for all variables, the final data preparation step included the scaling of the samples substituting each value with a respective Z-score. After scaling, the mean is set to 0 and the distance from the mean is in units of 1 standard deviation:

$$
z = \frac{x - \bar{x}}{\sigma}
$$

The resulting z-scores, to be used in the following cluster analysis are presented in the table below:

```{r z-scoring, echo=FALSE, message=FALSE, warning=FALSE}
library(cluster)
library(dplyr)
library(magrittr)
library(knitr)
library(tidyr)
library(purrr)
library(tibble)

# Actual scaling using the scale() function
water_analysis_clust_scaled <- scale(water_analysis_clust)

# Print the scaled data
kable(water_analysis_clust_scaled,align = 'c',  caption = 'Scaled data Z-scores')
```

## 2.2.Clustering

After having scaled the dataset we can now calculate the dissimilarity matrix (the distance $\delta_{i,j}$ between each pair of observations). Here the **Manhattan** or **City Block Distance (CDB)** was used as a measure of similarity . Other similarity measures can be used substituting the `method =` parameter with `“euclidean”, “maximum”, “canberra”, “binary”, “minkowski”` respectively. In this matrix, the value represent the distance between objects. The values on the diagonal of the matrix represent the distance between objects and themselves (which are zero). We can perform agglomerative HC with `hclust` specify the agglomeration method to be used (i.e. "complete", "average", "single", "ward.D"). We can then plot the dendrogram.

```{r HCA, echo=FALSE}

d <- dist(water_analysis_clust_scaled, method = sim_meas)

hc1 <- hclust(d, method = agg_method )

plot(hc1, cex = 0.6, hang = -1)
```

For the cluster validation:

```{r cluster optimal number, echo=FALSE, fig.height=3, fig.width=8}

library(factoextra)

par(mfrow=c(1,3))

fviz_nbclust(water_analysis_clust_scaled, FUN = hcut, method = "wss")
```

## 3.3.1. Dendrogram based on chosen number of clusters

Based on the number of clusters chosen the previous dendrogram is respectively colored to portray the clustering:

```{r cut the dendrogram, echo=FALSE, fig.height=10}
library(factoextra)

dendro= fviz_dend(hc1, cex = 0.5, k = numberofclusters, horiz = T,main = "",
          xlab = "", ylab = "Distance", color_labels_by_k = T, palette =  "aaas")

ggsave(file="dendro.svg", dendro, width=10, height=8)

dendro
```

Each sample's respective cluster value is added as a column in `water_analysis` dataframe.

```{r add clusters to data, include=FALSE}

clusterCut <- cutree(hc1,numberofclusters) 

water_analysis= cbind(water_analysis, Cluster = clusterCut )
```

```{r Export water_analysis with clusters for GIS, include=FALSE}

hydroExport = "/HydroWorkflow_export.csv"

gispath = c(wd,hydroExport)
write.csv( water_analysis,  paste(gispath, collapse = ""), row.names = FALSE)
```

```{r second Housekeeping, include=FALSE}
rm(list=c("res.hc","hc1","water_analysis_clust","water_analysis_clust_scaled","map_data","myMap","numberofclusters","clusterCut","d"))
```

# 3. Data visualization

## 3.1. Piper plot

```{r Functions for piper plot, include=FALSE}

library(ggplot2)

# this function will transform the data into 100%
transform_piper_data <- function(Mg, Ca, Cl,SO4, name=NULL){
  if(is.null(name)){
    name = rep(1:length(Mg),3)
  } else {
    name = rep(name,3)
  }
  y1 <- Mg * 0.86603
  x1 <- 100*(1-(Ca/100) - (Mg/200))
  y2 <- SO4 * 0.86603
  x2 <-120+(100*Cl/100 + 0.5 * 100*SO4/100)
  new_point <- function(x1, x2, y1, y2, grad=1.73206){
    b1 <- y1-(grad*x1)
    b2 <- y2-(-grad*x2)
    M <- matrix(c(grad, -grad, -1,-1), ncol=2)
    intercepts <- as.matrix(c(b1,b2))
    t_mat <- -solve(M) %*% intercepts
    data.frame(x=t_mat[1,1], y=t_mat[2,1])
  }
  np_list <- lapply(1:length(x1), function(i) new_point(x1[i], x2[i], y1[i], y2[i]))
  npoints <- do.call("rbind",np_list)
  data.frame(observation=name,x=c(x1, x2, npoints$x), y=c(y=y1, y2, npoints$y))
}

### This is the actual function to call the piper plot
 
ggplot_piper <- function() {
  library(ggplot2)
  grid1p1 <<- data.frame(x1 = c(20, 40, 60, 80),
                         x2 = c(10, 20, 30, 40),
                         y1 = c(0, 0, 0, 0),
                         y2 = c(17.3206, 34.6412, 51.9618, 69.2824)) ## FIXME: how are these numbers generated???
  grid1p2 <<- data.frame(x1 = c(20, 40, 60, 80),
                         x2 = c(60, 70, 80, 90),
                         y1 = c(0, 0, 0, 0),
                         y2 = c(69.2824, 51.9618, 34.6412, 17.3206)) ## FIXME: how are these numbers generated???
  grid1p3 <<- data.frame(x1 = c(10, 20, 30, 40), 
                         x2 = c(90, 80, 70, 60),
                         y1 = c(17.3206, 34.6412, 51.9618, 69.2824), ## FIXME: how are these numbers generated???
                         y2 = c(17.3206, 34.6412, 51.9618, 69.2824)) ## FIXME: how are these numbers generated???
  grid2p1 <<- grid1p1
  grid2p1$x1 <- grid2p1$x1 + 120
  grid2p1$x2 <- grid2p1$x2 + 120
  grid2p2 <<- grid1p2
  grid2p2$x1 <- grid2p2$x1 + 120
  grid2p2$x2 <- grid2p2$x2 + 120
  grid2p3 <<- grid1p3
  grid2p3$x1 <- grid2p3$x1 + 120
  grid2p3$x2 <- grid2p3$x2 + 120
  grid3p1 <<- data.frame(x1 = c(100, 90, 80, 70),
                         y1 = c(34.6412, 51.9618, 69.2824, 86.603), ## FIXME: how are these numbers generated???
                         x2 = c(150, 140, 130, 120),
                         y2 = c(121.2442, 138.5648, 155.8854, 173.2060)) ## FIXME: how are these numbers generated???
  grid3p2 <<- data.frame(x1 = c(70, 80, 90, 100),
                         y1 = c(121.2442, 138.5648, 155.8854, 173.2060), ## FIXME: how are these numbers generated???
                         x2 = c(120, 130, 140, 150),
                         y2 = c(34.6412, 51.9618, 69.2824, 86.603)) ## FIXME: how are these numbers generated???
  
  label.size <- 5
  
  p <- ggplot() +
    
    ## left hand ternary plot
    geom_segment(aes(x =  0, y =  0,     xend = 100, yend = 0)) +
    geom_segment(aes(x =  0, y =  0,     xend =  50, yend = 86.603)) + ## FIXME: how are these numbers generated???
    geom_segment(aes(x = 50, y = 86.603, xend = 100, yend = 0)) + ## FIXME: how are these numbers generated???
    
    ## right hand ternary plot
    geom_segment(aes(x = 120, y = 0, xend = 220, yend =  0)) +
    geom_segment(aes(x = 120, y = 0, xend = 170, yend = 86.603)) +
    geom_segment(aes(x = 170, y = 86.603, xend = 220, yend = 0)) +
    
    ## Upper diamond
    geom_segment(aes(x = 110, y = 190.5266, xend =  60, yend = 103.9236)) +
    geom_segment(aes(x = 110, y = 190.5266, xend = 160, yend = 103.9236)) +
    geom_segment(aes(x = 110, y =  17.3206, xend = 160, yend = 103.9236)) +
    geom_segment(aes(x = 110, y =  17.3206, xend =  60, yend = 103.9236)) +
    
    ## Add grid lines to the plots
    geom_segment(aes(x = x1, y = y1, yend = y2, xend = x2), data = grid1p1, linetype = "dashed", size = 0.25, colour = "grey50") +
    geom_segment(aes(x = x1, y = y1, yend = y2, xend = x2), data = grid1p2, linetype = "dashed", size = 0.25, colour = "grey50") +
    geom_segment(aes(x = x1, y = y1, yend = y2, xend = x2), data = grid1p3, linetype = "dashed", size = 0.25, colour = "grey50") +
    geom_segment(aes(x = x1, y = y1, yend = y2, xend = x2), data = grid2p1, linetype = "dashed", size = 0.25, colour = "grey50") +
    geom_segment(aes(x = x1, y = y1, yend = y2, xend = x2), data = grid2p2, linetype = "dashed", size = 0.25, colour = "grey50") +
    geom_segment(aes(x = x1, y = y1, yend = y2, xend = x2), data = grid2p3, linetype = "dashed", size = 0.25, colour = "grey50") +
    geom_segment(aes(x = x1, y = y1, yend = y2, xend = x2), data = grid3p1, linetype = "dashed", size = 0.25, colour = "grey50") +
    geom_segment(aes(x = x1, y = y1, yend = y2, xend = x2), data = grid3p2, linetype = "dashed", size = 0.25, colour = "grey50") +
    
    ### Labels and grid values
    coord_fixed(ratio = 1) +  
    geom_text(aes(17,   50, label = "Mg"), angle = 60, size = label.size, parse = TRUE) +  
    geom_text(aes(82.5, 50, label = "Na+K"), angle = -60, size = label.size, parse = T) +
    geom_text(aes(50,  -10, label = "Ca"), size = label.size, parse = TRUE) +
    geom_text(aes(170,   -10, label = "Cl"), size = label.size, parse = TRUE) +
    geom_text(aes(205,    50, label = "SO4"), angle = -60, size = label.size, parse = TRUE) +
    geom_text(aes(137.5,  50, label = "HCO3"), angle = 60, size = label.size, parse = TRUE) +
    geom_text(aes( 72.5, 150, label = "SO4+Cl"), angle = 60, size = label.size, parse = TRUE) +
    geom_text(aes(147.5, 150, label = "Ca+Mg"), angle = -60, size = label.size, parse = TRUE) + 
    
    geom_text(aes(c(35, 25, 15, 5), grid1p2$y2, label = c(80, 60, 40, 20)), size = label.size -1, angle = 0) + # Mg axis
    geom_text(aes(c(95, 85, 75, 65), grid1p3$y2, label = c(80, 60, 40, 20)), size = label.size -1, angle = 60, vjust = -1, hjust = 0) + # Na axis
    geom_text(aes(c(20, 40, 60, 80), c(-5, -5, -5, -5), label = c(80, 60, 40, 20)), size = label.size -1, angle = -60, vjust = -.5) + # Ca axis
    geom_text(aes(c(155, 145, 135, 125), grid2p2$y2, label = c(20, 40, 60, 80)), size = label.size -1, angle = -60, vjust = -1, hjust = 1) + # HCO3 axis
    geom_text(aes(c(215, 205, 195, 185), grid2p3$y2, label = c(20, 40, 60, 80)), size = label.size -1, angle = 0) + # SO4 axis
    geom_text(aes(c(140, 160, 180, 200), c(-5, -5, -5, -5), label = c(20, 40, 60, 80)), size = label.size -1, angle = 60, vjust = -.5) + # Cl axis
    #geom_text(aes(grid3p1$x1 - 5, grid3p1$y1, label = c(80, 60, 40, 20)), size=3, angle = 60, vjust = -1.5, hjust = 1) + # diamond Na axis
    geom_text(aes(grid3p1$x2 + 5, grid3p1$y2, label = c(20, 40, 60, 80)), size = label.size -1, angle =  60, vjust = -1, hjust = 0) + # diamond Ca axis
    geom_text(aes(grid3p2$x1 - 5, grid3p2$y1, label = c(20, 40, 60, 80)), size = label.size -1, angle = -60, vjust = -1, hjust = 1) + # diamond SO4 axis
    #geom_text(aes(grid3p2$x2 + 5, grid3p2$y2, label = c(80, 60, 40, 20)), size=3, angle =  90) + # diamond HCO3 axis
    theme_bw() +
    theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank(),
          panel.border = element_blank(), axis.ticks = element_blank(),
          axis.text.x = element_blank(), axis.text.y = element_blank(),
          axis.title.x = element_blank(), axis.title.y = element_blank())
  return(p)
}
```

```{r Data preperation and piper plot, echo=FALSE, fig.height=10, fig.width=10}
library(ggplot2)
library(ggrepel)
library("hydrogeo")
library(plotly)

if(exists("CO3_meq")){
   CO3 = CO3_meq 
 }else{
   CO3 = replicate(length(water_analysis$Sample), 0)
 }

milliequivalents = list( Ca   = Ca_meq,
                         Mg   = Mg_meq,
                         Na   = Na_meq,
                         K    = K_meq,
                         Cl   = Cl_meq,
                         SO4  = SO4_meq,
                         CO3 = CO3,
                         HCO3 = HCO3_meq,
                         "Samples" = water_analysis$Sample,
                         "TDS" = water_analysis$TDS,
                         "Cluster" = water_analysis$Cluster)

### This transforms the meq/L to percents 
percents <- toPercent(milliequivalents)

data <- as.data.frame(percents)

### This applies plot coordinates to the variables
piper_data <- transform_piper_data(Ca   = data$Ca,
                                   Mg   = data$Mg,
                                   Cl   = data$Cl,
                                   SO4  = data$SO4,
                                   name = data$Samples)

piper_data <- merge(piper_data,
                     data[, c("TDS", "Cluster", "Samples")],
                     by.y = "Samples",
                     by.x = "observation")

#######

piper_data$Cluster= as.factor(piper_data$Cluster)
piper_labels = as.character(piper_data$observation)
piper_data$label = piper_labels
rm(piper_labels)

##### Only samples

#piper_1 = ggplot_piper() + geom_point(aes(x,y,colour=factor(observation), size = 0.05, alpha= .5), data=piper_data) + 
  #labs(color = "Water samples") + theme(legend.position="bottom")+geom_text_repel(data =piper_data, aes(x, y, label = label), size = 2, max.overlaps = 30)

#piper_1

#### Samples, TDS, Clusters

piper_2 = ggplot_piper() + geom_point(aes(x,y,colour=factor(Cluster), size = TDS, alpha= .8), data=piper_data) + 
  labs(color = "Cluster") + 
  theme(legend.position="bottom")+
  geom_text_repel(data =piper_data, aes(x, y, label = label), size = 3, max.overlaps = 30, alpha = 0.3 )

 piper_2 = piper_2 + scale_size_area()+ scale_size_continuous(range = c(1, 10))
 ggplotly(piper_2)
 
 ggsave(file="Piper.png", piper_2, width=10, height=10)
 
```

## 3.2. Shoeller plot

```{r Reorder milliequivalents data frame for the shoeller plot, include=FALSE}
library(tidyverse)

milliequivalents = as.data.frame(milliequivalents)
milliequivalents$Cluster = as.factor(milliequivalents$Cluster)

if (exists("NO3_meq")) {
  milliequivalents$NO3 = NO3_meq
}

if (exists("Br_meq")) {
  milliequivalents$Br =  Br_meq
}

if (exists("CO3_meq")) {
  milliequivalents$CO3 =  CO3_meq
}

### Elements and their order to be shown in shoeller plot.
milliequivalents_shoeller= milliequivalents%>% 
  select(Samples,Cluster,TDS,K,Na,Cl,Ca,SO4,Mg,HCO3)

### Copy the Ions (not Samples, Cluster, TDS) and place assign them as character (e.g. "Na", "cl" ) to the idmeasure.vars variable as instructed in the next chunk! 
```

```{r Schoeller Diagram, echo=FALSE, fig.height=12, fig.width=10, warning=FALSE}

library(dplyr)
library(directlabels)
library(reshape2)
library(scales)
library(plotly)

shoeller_data = subset(milliequivalents_shoeller, select=-c(TDS))
###
### HERE : assign the ions you want to plot to the idmeasure.vars variable
###
melted_shoeller_data = melt(shoeller_data,id.vars=c("Cluster","Samples"),idmeasure.vars = c("K","Na","Cl","Ca","SO4","Mg","HCO3"))

shoeller_plot= ggplot(data = melted_shoeller_data)+
  geom_line(aes(x = variable, y = value, group = Samples, colour = Cluster), alpha = 0.8)+
  geom_point(aes(x = variable, y = value,colour = Cluster, group = Samples), alpha= 0.5)+
  scale_x_discrete()+
  theme_light()+
  scale_y_continuous(trans = scales::log10_trans(),
                     breaks = scales::pretty_breaks(),
                     labels = prettyNum)+
  labs(y = "meq/L", x= "")+
  theme(legend.position="bottom")+
  annotation_logticks(sides = "lr")


ggsave(file= "Shoeller_all.png", shoeller_plot , width=10, height=12)
ggplotly(shoeller_plot)  
```

```{r Mean value for each cluster and mean shoeller plot, echo=FALSE, message=FALSE, warning=FALSE}
library(plotly)
library(dplyr)
library(knitr)
library(ggplot2)
library(reshape2)



### Choose the numeric elements to be averaged for each cluster
summary_milliequivalents = subset(shoeller_data, select=-c(Samples))

mean_values_of_clusters = aggregate(. ~ Cluster, data = summary_milliequivalents, FUN = function(x) c( mn = mean(x) ) )

kable(mean_values_of_clusters,align = 'c', caption = 'Mean values for each cluster ($meq/L$)')



mean_values_of_clusters = melt(mean_values_of_clusters,id.vars=c("Cluster"),idmeasure.vars = c("K","Na","Cl","Ca","SO4","Mg","HCO3"))

avg_shoeller= ggplot(data = mean_values_of_clusters)+
  geom_line(aes(x = variable, y = value, group = Cluster, colour = Cluster), alpha = 0.8)+
  geom_point(aes(x = variable, y = value,colour = Cluster, group =Cluster), alpha= 0.5)+
  scale_x_discrete()+
  theme_light()+
  scale_y_continuous(trans = scales::log10_trans(),
                     breaks = scales::pretty_breaks(),
                     labels = prettyNum)+
  labs(y = "meq/L", x= "")+
  theme(legend.position="bottom")+
  annotation_logticks(sides = "lr")

ggplotly(avg_shoeller)  
```

## 3.3. Boxplots (All measurements are in meq/L)

```{r Summarizing boxplots, echo=FALSE, fig.height=4}

library(ggplot2)
library(scales)
library(plotly)


### same y axis
box_com= ggplot(data = melted_shoeller_data, mapping = aes(x = variable, y = value, color= Cluster)) + 
  geom_boxplot()+
  scale_x_discrete()+
  theme_light()+
  labs(y = "", x= "")+
  theme(legend.position="bottom")+
  facet_wrap(~Cluster)+
  theme_light()

  ggplotly(box_com)


 
### free y axis
  
free_com =ggplot(data = melted_shoeller_data, mapping = aes(x = variable, y = value, color= Cluster)) + 
  geom_boxplot()+
  scale_x_discrete()+
  theme_light()+
  labs(y = "", x= "")+
  theme(legend.position="bottom")+
  facet_wrap(~Cluster, scales = "free")+
  theme_light()

ggplotly(free_com)

```

## 3.4. Composite diagrams

```{r Na-Cl, echo=FALSE}
library(ggplot2)
library(scales)
library(plotly)

Na_to_Cl_plot =ggplot(data=milliequivalents)+
  geom_point(aes(x = Cl , y = Na, color = Cluster))+
  geom_abline(intercept = 0, slope = 1, color = "grey", linetype = "dashed")+
  theme_light()+
  labs(y = "Na meq/L", x= "Cl meq/L")

ggplotly(Na_to_Cl_plot)

```

```{r Br-Cl, echo=FALSE}
library(ggplot2)
library(scales)
library(plotly)

if(exists("Br_meq")) {
  br_cl =ggplot(data = milliequivalents) +
    geom_point(data = subset(milliequivalents, Br > 0),aes(x = Cl , y = Br, color = Cluster)) +
    geom_abline(
      intercept = 0,
      slope = 1,
      color = "grey",
      linetype = "dashed"
    ) +
    theme_light() +
    labs(y = "Br meq/L", x = "Cl meq/L")
}

if(exists("Br_vs_Cl")){ggplotly(br_cl)}


```

```{r Ca to SO4, echo=FALSE}
library(ggplot2)
library(scales)
library(plotly)

Ca_to_SO4_plot =ggplot(data=milliequivalents)+
  geom_point(aes(x = SO4 , y = Ca, color = Cluster))+
  geom_abline(intercept = 0, slope = 1, color = "grey", linetype = "dashed")+
  theme_light()+
  labs(y = "Ca meq/L", x= "SO4 meq/L")

ggplotly(Ca_to_SO4_plot) 
```

```{r Na_plus_K_to_NaMgCaK, echo=FALSE}
library(plotly)
library(ggplot2)

Na_plus_K_to_NaMgCaK =ggplot(data=milliequivalents)+
  geom_point(aes(x = (Na+Mg+K+Ca) , y = Na+K, color = Cluster))+
  geom_abline(intercept = 0, slope = c(1,0.5,1.5), color = "grey", linetype = "dashed")+
  theme_light()+
  labs(y = "[Na + K] meq/L", x= "[Na+K+Mg+Ca] meq/L")

ggplotly(Na_plus_K_to_NaMgCaK)
```

```{r Ca_plus_Mg_to_HCO3, echo=FALSE}

library(plotly)
library(ggplot2)

Ca_plus_Mg_to_HCO3 =ggplot(data=milliequivalents)+
  geom_point(aes(x = HCO3 , y = (Ca+Mg), color = Cluster))+
  geom_abline(intercept = 0, slope = 1, color = "grey", linetype = "dashed")+
  theme_light()+
  labs(y = "[Ca+Mg] meq/L", x= "HCO3 meq/L")

ggplotly(Ca_plus_Mg_to_HCO3)

```

```{r Cl_to_HCO3, echo=FALSE}
library(plotly)
library(ggplot2)

Cl_to_HCO3 =ggplot(data=milliequivalents)+
  geom_point(aes(x = HCO3 , y = Cl, color = Cluster))+
  geom_abline(intercept = 0, slope = 1, color = "grey", linetype = "dashed")+
  theme_light()+
  labs(y = "Cl meq/L", x= "HCO3 meq/L")+
  scale_y_continuous(trans = scales::log10_trans(),
                   breaks = scales::pretty_breaks(),
                   labels = prettyNum)+
  scale_x_continuous(trans = scales::log10_trans(),
                     breaks = scales::pretty_breaks(),
                     labels = prettyNum)

ggplotly(Cl_to_HCO3)

```
